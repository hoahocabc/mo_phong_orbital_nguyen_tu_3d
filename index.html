<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orbital 3D — Billboard labels</title>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

  <style>
    html, body { height: 100%; margin: 0; background: #111; color: #fff; font-family: Inter, Arial, sans-serif; }
    body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    canvas { display:block; }

    /* Top panels container: empty shell, contains two panels left/right */
    #ui {
      position: fixed;
      left: 12px;
      right: 12px;
      top: 12px;
      display: flex;
      justify-content: space-between;
      pointer-events: none; /* let inner panels control pointer events */
      z-index: 10003; /* Ensure UI sits above canvas */
    }

    /* Panel (used for both left and right); pointer-events enabled */
    .panel {
      pointer-events: auto;
      background: rgba(0,0,0,0.55);
      padding: 12px;
      border-radius: 8px;
      box-sizing: border-box;
      color: #fff;
      box-shadow: 0 8px 22px rgba(0,0,0,0.6);
      min-width: 120px;
      max-width: 48%;
    }

    /* Left (buttons) should size to content and not expand too wide */
    #uiLeft {
      min-width: 120px;
      max-width: 46%;
      width: auto;
    }

    /* Right (inputs & orbital label) stays compact and aligned to right */
    #uiRight {
      min-width: 180px;
      max-width: 56%;
      width: auto;
      text-align: right;
    }

    #heroTitle {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10004;
      color: #ffffff;
      font-weight: 800;
      font-size: 18px;
      letter-spacing: 1px;
      text-transform: uppercase;
      pointer-events: none;
      text-align: center;
    }

    #footerCredit {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10004;
      color: #e6f0fb;
      font-weight: 700;
      font-size: 13px;
      pointer-events: none;
      text-align: center;
    }

    #uiHeader {
      display:flex;
      justify-content: flex-end;
      margin-bottom: 8px;
      gap: 8px;
      align-items: center;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 8px;
      align-items: flex-end;
    }

    #ui label {
      font-size: 13px;
      margin: 0;
      color: #e6f0fb;
      white-space: nowrap;
      display: block;
      text-align: left;
    }

    :root {
      --field-width: 160px;
      --field-height: 28px;
      --field-font-size: 14px;
    }

    /* Inputs and selects (right panel) keep the controlled width variable */
    #uiRight input[type="number"], #uiRight input[type="text"], #uiRight select {
      width: var(--field-width);
      height: var(--field-height);
      padding: 3px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.03);
      color: #fff;
      font-size: var(--field-font-size);
      box-sizing: border-box;
      outline: none;
      transition: box-shadow .12s ease, border-color .12s ease, filter .08s ease;
      display: inline-block;
      line-height: 1;
    }

    .select-wrap {
      position: relative;
      width: var(--field-width);
      height: var(--field-height);
      display: inline-block;
    }
    /* DEFAULT: closed state -> black background, white text */
    select.lang-select {
      width: 100%;
      height: 100%;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.08);
      background: #000000;      /* closed background = black */
      color: #ffffff;           /* closed text = white */
      font-weight: 700;
      padding: 0 34px 0 12px;
      box-sizing: border-box;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      cursor: pointer;
      -webkit-text-fill-color: #ffffff;
    }
    .select-wrap::after {
      content: "";
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 6px solid #ffffff;
      pointer-events: none;
    }

    /* When the dropdown is focused / open in many browsers, options will be visible.
       Ensure option styling: white background + dark text; hovered option blue + white text. */
    select.lang-select option,
    select.lang-select optgroup {
      color: #042027 !important;
      background-color: #ffffff !important;
    }
    /* Hover style for options (browsers vary; we include it for those honoring option hover) */
    select.lang-select option:hover,
    select.lang-select option:focus {
      background-color: #0a6fb3 !important; /* blue hover */
      color: #ffffff !important;
    }

    /* Also ensure when select has focus its caret/arrow uses dark color for visibility */
    .select-wrap select.lang-select:focus,
    .select-wrap select.lang-select:active {
      color: #042027;
      background: #ffffff;
      -webkit-text-fill-color: #042027;
    }

    .actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 6px;
      align-items: flex-start;
      position: relative;
      z-index: 10003;
    }

    /* Ensure buttons in left panel have equal width (use same variable as inputs).
       This guarantees equal-sized buttons while leaving other styles intact. */
    #uiLeft .actions { align-items: stretch; }
    #uiLeft .btn, #uiLeft .btn.secondary, #uiLeft .actions > * {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: var(--field-width);
      height: var(--field-height);
      padding: 0 12px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
      background: #ffffff;
      color: #042027;
      cursor: pointer;
      font-weight: 600;
      font-size: var(--field-font-size);
      box-sizing: border-box;
      transition: transform .12s ease, box-shadow .12s ease, filter .08s ease;
      box-shadow: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
      z-index: 10004;
      min-width: 0;
      max-width: 100%;
    }
    /* Slightly different appearance for secondary */
    #uiLeft .btn.secondary {
      background: linear-gradient(#ffffff,#e9f3f8);
      color: #042027;
      border: 1px solid rgba(0,0,0,0.06);
    }

    /* Hover effect for accessible affordance */
    #uiLeft .btn:hover, #uiLeft .btn:focus {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.5);
      filter: brightness(1.03);
      outline: none;
    }

    /* Orbital label (move to right panel & right-align) */
    #orbitalLabel {
      margin-top: 6px;
      font-size: 15px;
      color: #cfeff8;
      line-height: 1.2;
      text-align: right;
      width: var(--field-width);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
      z-index: 10005;
      background: transparent;
      box-sizing: border-box;
      margin-left: auto;
    }
    #orbitalLabel sub { font-size: 0.85em; vertical-align: sub; }
    #orbitalLabel sup { font-size: 0.75em; vertical-align: super; }

    #progress {
      position: absolute;
      left: 8px;
      top: 8px;
      color: #fff;
      font-size: 14px;
      z-index: 10005;
      pointer-events: none;
      background: rgba(0,0,0,0.25);
      padding: 4px 8px;
      border-radius: 4px;
      display:none;
    }
    #status {
      position: absolute;
      right: 12px;
      top: 12px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 8px 10px;
      border-radius: 6px;
      z-index: 10005;
      font-size: 13px;
      max-width: 360px;
      white-space: pre-wrap;
      display:none;
    }

    .axis-label, #xLabel, #yLabel, #zLabel {
      font-size: 15px;
      font-weight: 600;
      color: #f1f8fb;
    }

    @media (max-width:480px){
      :root { --field-width: calc(100% - 40px); }
      #ui { left: 8px; right: 8px; top: 8px; }
      .panel { padding: 10px; }
      #ui .btn, #ui input[type="number"] { width: calc(100% - 40px); }
      .select-wrap { width: var(--field-width); }
      select.lang-select { width: 100%; }
      #heroTitle { font-size: 14px; top: 8px; }
      #footerCredit { font-size: 12px; bottom: 8px; }
      /* stack panels vertically on very small screens */
      #ui { flex-direction: column; gap:8px; align-items: stretch; }
      #uiLeft, #uiRight { max-width: 100%; width: 100%; text-align: left; }
      #orbitalLabel { text-align: left; width: auto; }
    }
  </style>
</head>
<body>
  <div id="heroTitle" aria-hidden="true">Mô phỏng Orbital 3D</div>

  <!-- Keep wrapper #ui for existing JS compatibility; it contains two panels -->
  <div id="ui" role="region" aria-label="Điều khiển">
    <!-- Left panel: buttons and language (keeps #uiHeader for existing scripts) -->
    <div id="uiLeft" class="panel" aria-label="Actions panel">
      <div id="uiHeader">
        <div class="select-wrap" aria-hidden="false">
          <label id="langHiddenLabel" for="langSelect" style="display:none">Ngôn ngữ</label>
          <select id="langSelect" class="lang-select" aria-label="Chọn ngôn ngữ">
            <option value="vi" selected>Tiếng Việt</option>
            <option value="en">English</option>
          </select>
        </div>
      </div>

      <div class="actions" role="toolbar" aria-label="Hành động">
        <!-- Existing button kept but visually on left-panel -->
        <button id="toggleRotateBtn" class="btn secondary" title="Bật/Tắt xoay tự động" aria-label="Bật/Tắt xoay tự động" data-i18n-key="toggleRotate">Tắt xoay tự động</button>
        <!-- overlay/electron toggle buttons (if created by sketch.js they will be appended into #ui .actions) -->
      </div>
    </div>

    <!-- Right panel: inputs + orbital label -->
    <div id="uiRight" class="panel" aria-label="Controls">
      <div class="field">
        <label id="nLabel" for="nInput">Số lượng tử chính (n)</label>
        <input id="nInput" type="number" min="1" value="1" inputmode="numeric" />
      </div>

      <div class="field">
        <label id="lLabel" for="lInput">Số lượng tử phụ (l)</label>
        <input id="lInput" type="number" min="0" value="0" inputmode="numeric" />
      </div>

      <div class="field">
        <label id="mLabel" for="mInput">Số lượng tử từ (m<sub>l</sub>)</label>
        <input id="mInput" type="number" value="0" inputmode="numeric" />
      </div>

      <div class="field">
        <label id="electronSizeLabel" for="electronSizeInput">Kích thước electron</label>
        <input id="electronSizeInput" type="number" min="0.1" step="0.1" value="1" inputmode="numeric" />
      </div>

      <div class="field">
        <label id="numPointsLabel" for="numElectronsInput">Số điểm</label>
        <!-- allow 0 as a valid sentinel to turn off electrons & overlay -->
        <input id="numElectronsInput" type="number" min="0" max="2000000" value="5000" inputmode="numeric" />
      </div>

      <div class="actions" style="align-items:flex-end;">
        <div id="orbitalLabel" aria-live="polite">Orbital: 1s</div>
      </div>
    </div>
  </div>

  <div id="footerCredit" aria-hidden="true">© HÓA HỌC ABC</div>

  <div id="progress">Đang tải...</div>
  <div id="status" role="status" aria-live="polite"></div>

  <!-- Load p5 and sketch (deferred so initial render isn't blocked). Order preserved by defer. -->
  <script defer src="https://cdn.jsdelivr.net/npm/p5@1.8.0/lib/p5.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/p5@1.8.0/lib/addons/p5.dom.min.js"></script>
  <script defer src="sketch.js"></script>

  <!-- Localization & UI behavior script (keeps parity with sketch.js expectations) -->
  <script>
    if (!localStorage.getItem('orbital_lang')) localStorage.setItem('orbital_lang', 'vi');

    function orbitalHtmlFromQuantum(n, l, m) {
      n = parseInt(n,10); l = parseInt(l,10); m = parseInt(m,10);
      if (isNaN(l)) return 'unknown';
      if (isNaN(m) || Math.abs(m) > l) return 'invalid';
      if (!isNaN(n) && (l < 0 || l >= n)) return 'invalid';

      // l = 0 -> s
      if (l === 0) return 's';

      // l = 1 -> p: mapping px/pz/py for m = 1/0/-1 to match earlier UI
      if (l === 1) {
        if (m === 0) return 'p<sub>z</sub>';
        if (m === 1) return 'p<sub>x</sub>';
        if (m === -1) return 'p<sub>y</sub>';
        return 'p';
      }

      // l = 2 -> d: explicit mapping
      if (l === 2) {
        if (m === 0) return 'd<sub>z<sup>2</sup></sub>';
        if (m === 1) return 'd<sub>xz</sub>';
        if (m === -1) return 'd<sub>yz</sub>';
        if (m === 2) return 'd<sub>x<sup>2</sup>-y<sup>2</sup></sub>';
        if (m === -2) return 'd<sub>xy</sub>';
        return 'd';
      }

      // l = 3 -> f (map common real combinations)
      if (l === 3) {
        switch (m) {
          case 0: return 'f<sub>z<sup>3</sup></sub>';          // fz3
          case 1: return 'f<sub>xz<sup>2</sup></sub>';        // fxz2
          case -1: return 'f<sub>yz<sup>2</sup></sub>';       // fyz2
          case 2: return 'f<sub>x<sup>2</sup>z</sub>';        // fx2z
          case -2: return 'f<sub>y<sup>2</sup>z</sub>';       // fy2z
          case 3: return 'f<sub>x<sup>3</sup></sub>';         // fx3
          case -3: return 'f<sub>y<sup>3</sup></sub>';        // fy3
          default: return 'f';
        }
      }

      // l = 4 -> g (map typical component-like names)
      if (l === 4) {
        switch (m) {
          case 0: return 'g<sub>z<sup>4</sup></sub>';
          case 1: return 'g<sub>xz<sup>3</sup></sub>';
          case -1: return 'g<sub>yz<sup>3</sup></sub>';
          case 2: return 'g<sub>x<sup>2</sup>z<sup>2</sup></sub>';
          case -2: return 'g<sub>y<sup>2</sup>z<sup>2</sup></sub>';
          case 3: return 'g<sub>x<sup>3</sup>z</sub>';
          case -3: return 'g<sub>y<sup>3</sup>z</sub>';
          case 4: return 'g<sub>x<sup>4</sup></sub>';
          case -4: return 'g<sub>y<sup>4</sup></sub>';
          default: return 'g';
        }
      }

      // For higher l (>=5) provide a reasonable component-like label if possible,
      // otherwise fall back to single-letter shell name (f/g/h/...).
      const letters = ['s','p','d','f','g','h','i','k','l','m','n','o'];
      const letter = letters[l] || `l${l}`;
      // try to return letter with m when it's small; otherwise only letter
      if (Math.abs(m) <= 4) {
        // generic pattern: letter<sub>m</sub>
        return `${letter}<sub>${m}</sub>`;
      }
      return `${letter}`;
    }

    (function(){
      const langSelect = document.getElementById('langSelect');
      const nEl = document.getElementById('nInput');
      const lEl = document.getElementById('lInput');
      const mEl = document.getElementById('mInput');
      const label = document.getElementById('orbitalLabel');
      const toggleBtn = document.getElementById('toggleRotateBtn');
      const nLabelEl = document.getElementById('nLabel');
      const lLabelEl = document.getElementById('lLabel');
      const mLabelEl = document.getElementById('mLabel');
      const electronSizeLabelEl = document.getElementById('electronSizeLabel');
      const numPointsLabelEl = document.getElementById('numPointsLabel');
      const uiRegion = document.getElementById('ui');
      const langHiddenLabel = document.getElementById('langHiddenLabel');
      const progressEl = document.getElementById('progress');
      const statusEl = document.getElementById('status');
      const heroTitleEl = document.getElementById('heroTitle');

      const translations = {
        vi: {
          heroTitle: 'Mô phỏng Orbital 3D',
          nLabel: 'Số lượng tử chính (n)',
          lLabel: 'Số lượng tử phụ (l)',
          mLabel: 'Số lượng tử từ (m<sub>l</sub>)',
          electronSizeLabel: 'Kích thước electron',
          numPointsLabel: 'Số điểm',
          toggleRotateOn: 'Tắt xoay tự động',
          toggleRotateOff: 'Bật xoay tự động',
          toggleRotateOnTitle: 'Tắt chế độ xoay tự động',
          toggleRotateOffTitle: 'Bật chế độ xoay tự động',
          toggleOverlayOn: 'Tắt lớp phủ',
          toggleOverlayOff: 'Bật lớp phủ',
          orbitalPrefix: 'Orbital:',
          unknownText: 'chưa xác định',
          invalidRangeL: 'không hợp lệ (phải có 0 ≤ l ≤ n−1)',
          invalidRangeM: 'không hợp lệ (|m| ≤ l)',
          invalidGeneric: 'không hợp lệ',
          langOptionText_vi: 'Tiếng Việt',
          langOptionText_en: 'English',
          langSelectTitle: 'Chuyển ngôn ngữ',
          controlsRegion: 'Điều khiển',
          langHiddenLabel: 'Ngôn ngữ',
          progressLoading: 'Đang tải...',
          actionsToolbarLabel: 'Hành động',
          statusDefault: '',
          toggleElectronsOn: 'Tắt electron',
          toggleElectronsOff: 'Bật electron',
          toggleElectronsOnTitle: 'Tắt hiển thị electron',
          toggleElectronsOffTitle: 'Bật hiển thị electron'
        },
        en: {
          heroTitle: 'Orbital 3D simulator',
          nLabel: 'Principal quantum number (n)',
          lLabel: 'Azimuthal quantum number (l)',
          mLabel: 'Magnetic quantum number (m<sub>l</sub>)',
          electronSizeLabel: 'Electron size',
          numPointsLabel: 'Number of points',
          toggleRotateOn: 'Turn auto-rotate off',
          toggleRotateOff: 'Turn auto-rotate on',
          toggleRotateOnTitle: 'Turn auto-rotate off',
          toggleRotateOffTitle: 'Turn auto-rotate on',
          toggleOverlayOn: 'Turn overlay off',
          toggleOverlayOff: 'Turn overlay on',
          orbitalPrefix: 'Orbital:',
          unknownText: 'unknown',
          invalidRangeL: 'invalid (must have 0 ≤ l ≤ n−1)',
          invalidRangeM: 'invalid (|m| ≤ l)',
          invalidGeneric: 'invalid',
          langOptionText_vi: 'Tiếng Việt',
          langOptionText_en: 'English',
          langSelectTitle: 'Switch language',
          controlsRegion: 'Controls',
          langHiddenLabel: 'Language',
          progressLoading: 'Loading...',
          actionsToolbarLabel: 'Actions',
          statusDefault: '',
          toggleElectronsOn: 'Turn electrons off',
          toggleElectronsOff: 'Turn electrons on',
          toggleElectronsOnTitle: 'Turn electrons off',
          toggleElectronsOffTitle: 'Turn electrons on'
        }
      };

      let currentLang = localStorage.getItem('orbital_lang') || 'vi';
      // localAutoRotate is only for label text sync in this closure
      let localAutoRotate = (typeof window.autoRotate !== 'undefined') ? !!window.autoRotate : true;

      function updateFieldWidth() {
        const labels = Array.from(document.querySelectorAll('#uiRight .field > label'));
        if (!labels.length) return;
        labels.forEach(l => { l.style.width = ''; });
        document.querySelectorAll('.select-wrap').forEach(sw => { sw.style.width = ''; });

        let maxW = 0;
        labels.forEach(l => {
          const w = Math.ceil(l.scrollWidth) + 10;
          if (w > maxW) maxW = w;
        });
        const newWidth = Math.max(96, maxW);
        document.documentElement.style.setProperty('--field-width', newWidth + 'px');
      }

      function applyTranslations() {
        const t = translations[currentLang] || translations.vi;
        if (heroTitleEl) heroTitleEl.textContent = t.heroTitle || '';
        nLabelEl.innerHTML = t.nLabel;
        lLabelEl.innerHTML = t.lLabel;
        mLabelEl.innerHTML = t.mLabel;
        electronSizeLabelEl.innerHTML = t.electronSizeLabel;
        numPointsLabelEl.innerHTML = t.numPointsLabel;
        const viOption = langSelect.querySelector('option[value="vi"]');
        const enOption = langSelect.querySelector('option[value="en"]');
        if (viOption) viOption.textContent = t.langOptionText_vi;
        if (enOption) enOption.textContent = t.langOptionText_en;
        langSelect.title = t.langSelectTitle;
        langHiddenLabel.textContent = t.langHiddenLabel;
        if (uiRegion) uiRegion.setAttribute('aria-label', t.controlsRegion || 'Controls');
        const actionsToolbar = document.querySelector('#uiLeft .actions');
        if (actionsToolbar) actionsToolbar.setAttribute('aria-label', t.actionsToolbarLabel || 'Actions');
        langSelect.value = currentLang === 'en' ? 'en' : 'vi';
        document.documentElement.lang = currentLang === 'en' ? 'en' : 'vi';
        refreshLabel();
        if (progressEl) progressEl.textContent = t.progressLoading || '';
        if (statusEl && !statusEl.textContent) statusEl.textContent = t.statusDefault || '';
        document.querySelectorAll('[data-i18n-key]').forEach(el => {
          const key = el.dataset.i18nKey;
          if (!key) return;
          if (key === 'toggleRotate') return;
          if (key === 'toggleOverlay') {
            const isOn = el.dataset.state === 'on' || el.getAttribute('aria-pressed') === 'true';
            el.textContent = isOn ? (t.toggleOverlayOn || '') : (t.toggleOverlayOff || '');
            el.title = isOn ? (t.toggleOverlayOnTitle || el.textContent) : (t.toggleOverlayOffTitle || el.textContent);
            el.setAttribute('aria-label', el.title);
            return;
          }
          if (key === 'toggleElectrons') {
            const isOn = el.dataset.state === 'on' || el.getAttribute('aria-pressed') === 'true';
            el.textContent = isOn ? (t.toggleElectronsOn || '') : (t.toggleElectronsOff || '');
            el.title = isOn ? (t.toggleElectronsOnTitle || el.textContent) : (t.toggleElectronsOffTitle || el.textContent);
            el.setAttribute('aria-label', el.title);
            return;
          }
          if (t[key]) {
            el.textContent = t[key];
            if (t[key + 'Title']) { el.title = t[key + 'Title']; el.setAttribute('aria-label', t[key + 'Title']); }
          }
        });
        // ensure the rotate toggle reflects the current language strings
        try { if (typeof updateToggleRotateText === 'function') updateToggleRotateText(); } catch (e) {}
        setTimeout(updateFieldWidth, 20);
      }

      function refreshLabel() {
        const nRaw = nEl.value;
        const lRaw = lEl.value;
        const mRaw = mEl.value;
        const t = translations[currentLang] || translations.vi;
        const obsOrb = orbitalHtmlFromQuantum(nRaw, lRaw, mRaw);
        const nParsed = parseInt(nRaw, 10);
        const nPrefix = isNaN(nParsed) ? '?' : nParsed;
        if (obsOrb === 'unknown') {
          label.innerHTML = `${t.orbitalPrefix} ${t.unknownText}`;
          return;
        }
        if (obsOrb === 'invalid') {
          const lParsed = parseInt(lRaw, 10);
          const mParsed = parseInt(mRaw, 10);
          if (!isNaN(nParsed) && !isNaN(lParsed) && lParsed >= nParsed) {
            label.innerHTML = `${t.orbitalPrefix} ${t.invalidRangeL}`;
            return;
          }
          if (!isNaN(lParsed) && !isNaN(mParsed) && Math.abs(mParsed) > Math.abs(lParsed)) {
            label.innerHTML = `${t.orbitalPrefix} ${t.invalidRangeM}`;
            return;
          }
          label.innerHTML = `${t.orbitalPrefix} ${t.invalidGeneric}`;
          return;
        }
        label.innerHTML = `${t.orbitalPrefix} ${nPrefix}${obsOrb}`;
      }

      function updateConstraintsFromN() {
        const nVal = parseInt(nEl.value, 10);
        const maxL = (isNaN(nVal) ? 0 : Math.max(0, nVal - 1));
        lEl.max = maxL;
        let lParsed = parseInt(lEl.value, 10);
        if (isNaN(lParsed)) lParsed = 0;
        if (lParsed > maxL) lEl.value = maxL;
        if (lParsed < 0) lEl.value = 0;
        updateConstraintsFromL();
      }

      function updateConstraintsFromL() {
        const lVal = parseInt(lEl.value, 10);
        const absL = isNaN(lVal) ? 0 : Math.abs(lVal);
        mEl.min = -absL;
        mEl.max = absL;
        let mParsed = parseInt(mEl.value, 10);
        if (isNaN(mParsed)) mParsed = 0;
        if (mParsed < -absL) mEl.value = -absL;
        if (mParsed > absL) mEl.value = absL;
      }

      [nEl, lEl, mEl].forEach(el => {
        if (!el) return;
        el.addEventListener('input', () => {
          if (el === nEl) updateConstraintsFromN();
          if (el === lEl) updateConstraintsFromL();
          refreshLabel();
        });
        el.addEventListener('change', () => {
          if (el === nEl) updateConstraintsFromN();
          if (el === lEl) updateConstraintsFromL();
          refreshLabel();
        });
      });

      // We no longer force >=1 here — sketch.js will handle 0 logic centrally.
      // Keep light UX guard: prevent Enter from submitting and leaving blank
      const numEl = document.getElementById('numElectronsInput');
      if (numEl) {
        numEl.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter') {
            ev.preventDefault();
            try { numEl.blur(); } catch (e) {}
          }
        });
      }

      setTimeout(() => {
        updateConstraintsFromN();
        refreshLabel();
        setTimeout(updateFieldWidth, 60);
      }, 20);

      function initLangSelect() {
        langSelect.value = (currentLang === 'en') ? 'en' : 'vi';
      }

      langSelect.addEventListener('change', () => {
        currentLang = langSelect.value === 'en' ? 'en' : 'vi';
        localStorage.setItem('orbital_lang', currentLang);
        initLangSelect();
        applyTranslations();
      });

      initLangSelect();
      applyTranslations();

      let _fwTimeout = null;
      window.addEventListener('resize', () => {
        if (_fwTimeout) clearTimeout(_fwTimeout);
        _fwTimeout = setTimeout(updateFieldWidth, 80);
      });

      function updateToggleRotateText() {
        const t = translations[currentLang] || translations.vi;
        // sync with real state in window.autoRotate if available
        const ar = (typeof window.autoRotate !== 'undefined') ? !!window.autoRotate : localAutoRotate;
        localAutoRotate = ar;
        const text = ar ? t.toggleRotateOn : t.toggleRotateOff;
        toggleBtn.textContent = text;
        const title = ar ? (t.toggleRotateOnTitle || t.toggleRotateOn) : (t.toggleRotateOffTitle || t.toggleRotateOff);
        toggleBtn.title = title;
        toggleBtn.setAttribute('aria-label', title);
      }

      // expose this helper globally so sketch.js can call it when autoRotate changes
      window.updateToggleRotateText = updateToggleRotateText;

      toggleBtn.addEventListener('click', (e) => {
        // prefer sketch-provided toggle if present
        if (typeof window.toggleAutoRotate === 'function') {
          window.toggleAutoRotate();
          // immediately sync the label with the authoritative window.autoRotate
          try { localAutoRotate = !!window.autoRotate; } catch (e) {}
          try { updateToggleRotateText(); } catch (e) {}
        } else {
          // fallback: flip local flag if sketch not ready yet
          localAutoRotate = !localAutoRotate;
          try { updateToggleRotateText(); } catch (e) {}
          try { window.autoRotate = localAutoRotate; } catch (err) {}
        }
      });

      window.refreshOrbitalLabel = refreshLabel;

      window.localizeNewElement = function(elem) {
        if (!elem) return;
        elem = (elem instanceof Element) ? elem : (elem.elt || null);
        if (!elem) return;
        if (elem.dataset && elem.dataset.i18nKey) {
          const key = elem.dataset.i18nKey;
          const t = translations[currentLang] || translations.vi;
          if (key === 'toggleOverlay') {
            const isOn = elem.dataset.state === 'on' || elem.getAttribute('aria-pressed') === 'true';
            elem.textContent = isOn ? (t.toggleOverlayOn || '') : (t.toggleOverlayOff || '');
            elem.title = isOn ? (t.toggleOverlayOnTitle || elem.textContent) : (t.toggleOverlayOffTitle || elem.textContent);
            elem.setAttribute('aria-label', elem.title);
            return;
          }
          if (key === 'toggleElectrons') {
            const isOn = elem.dataset.state === 'on' || elem.getAttribute('aria-pressed') === 'true';
            elem.textContent = isOn ? (t.toggleElectronsOn || '') : (t.toggleElectronsOff || '');
            elem.title = isOn ? (t.toggleElectronsOnTitle || elem.textContent) : (t.toggleElectronsOffTitle || elem.textContent);
            elem.setAttribute('aria-label', elem.title);
            return;
          }
          if (t[key]) {
            elem.textContent = t[key];
            if (t[key + 'Title']) { elem.title = t[key + 'Title']; elem.setAttribute('aria-label', t[key + 'Title']); }
            return;
          }
        }
      };

      window.setLocalizedProgress = function(show, customText) {
        const t = translations[currentLang] || translations.vi;
        if (!progressEl) return;
        if (show) {
          progressEl.style.display = 'block';
          progressEl.textContent = customText || t.progressLoading || '';
        } else {
          progressEl.style.display = 'none';
        }
      };

      window.setLocalizedStatus = function(text) {
        if (!statusEl) return;
        statusEl.textContent = text || '';
        statusEl.style.display = text ? 'block' : 'none';
      };

    })();
  </script>

  <script>
    // Watchdog + global error handlers
    (function(){
      const progressEl = document.getElementById('progress');
      const statusEl = document.getElementById('status');

      function showStatusMessage(msg, extra) {
        try {
          if (progressEl) progressEl.style.display = 'none';
          if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.textContent = msg + (extra ? ("\n\n" + extra) : '');
          } else {
            console.warn('STATUS:', msg, extra || '');
          }
        } catch (e) { console.error(e); }
      }

      window.addEventListener('error', function(evt) {
        const msg = 'Lỗi JavaScript: ' + (evt && evt.message ? String(evt.message) : 'Unknown error');
        const file = evt && evt.filename ? ('\nFile: ' + evt.filename + ':' + evt.lineno) : '';
        console.error('Global error caught', evt);
        showStatusMessage('Có lỗi xảy ra khi khởi tạo ứng dụng.', msg + file);
      });

      window.addEventListener('unhandledrejection', function(evt) {
        console.error('Unhandled promise rejection', evt);
        showStatusMessage('Có lỗi bất ngờ (unhandled promise rejection).', String(evt && evt.reason ? evt.reason : evt));
      });

      function checkP5Immediate() {
        if (typeof window.p5 === 'undefined' && typeof window.createCanvas === 'undefined') {
          showStatusMessage('Thư viện p5.js không tải được.', 'Kiểm tra kết nối mạng hoặc URL CDN. Nếu bạn deploy trên GitHub Pages, đảm bảo tệp p5 được phép tải từ CDN hoặc thay bằng bản local.');
        }
      }

      setTimeout(checkP5Immediate, 1200);

      const WATCHDOG_MS = 7000;
      setTimeout(() => {
        if (!window.orbitalReady) {
          let msg = 'Việc khởi tạo mất quá lâu hoặc bị lỗi — vẫn hiện "Loading...".';
          let extra = 'Mở DevTools (Console) để xem lỗi chi tiết. Kiểm tra:\n' +
                      '- p5.js và sketch.js có tải thành công? (Kiểm tra Network tab)\n' +
                      '- Đường dẫn tới sketch.js chính xác không khi deploy lên GitHub (có thể cần base path)?\n' +
                      '- Nếu dùng GitHub Pages, kiểm tra console/network để xem tệp có trả về 404 hay không.';
          showStatusMessage(msg, extra);
        }
      }, WATCHDOG_MS);
    })();
  </script>
</body>
</html>